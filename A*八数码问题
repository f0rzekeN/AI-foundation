import sys
import heapq
def manhattan(state): #计算曼哈顿距离
    target = (1, 2, 3, 4, 5, 6, 7, 8, 0) #目标状态
    distance = 0
    for i in range(9):
        if state[i] == 0:
            continue  #跳过空格
        correct_row, correct_col = (state[i]-1) // 3, (state[i]-1) % 3 #当前数字正确位置的行和列
        current_row, current_col = i // 3, i % 3 #当前数字实际位置的行和列
        distance += abs(correct_row - current_row) + abs(correct_col - current_col)
    return distance

def solve_puzzle():
    input_str = sys.stdin.readline().strip().split()
    start = []
    for c in input_str:
        if c == 'x':
            start.append(0)
        else:
            start.append(int(c))
    start = tuple(start)
    goal = (1, 2, 3, 4, 5, 6, 7, 8, 0)
    if start == goal:
        print("")
        return
    directions = [(-1, 0, 'u'), (1, 0, 'd'), (0, -1, 'l'), (0, 1, 'r')]
    heap = [] #优先队列，（f值，g值，当前状态，移动路径）
    heapq.heappush(heap, (manhattan(start), 0, start, "")) #初始状态的f值是曼哈顿距离，g值为0，移动路径为空
    visited = {start: 0} #记录已经访问过的状态及其对应的最小g值
    while heap:
        f, g, state, path = heapq.heappop(heap) #从堆中取出f值最小的状态
        if state == goal:
            print(path)
            return
        zero_index = state.index(0)
        x, y = zero_index // 3, zero_index % 3
        for dx, dy, move in directions: #生成所有可能的下一个状态
            nx, ny = x + dx, y + dy
            if 0 <= nx < 3 and 0 <= ny < 3:
                new_index = nx * 3 + ny
                new_state = list(state)
                new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
                new_state = tuple(new_state)
                new_g = g + 1
                new_f = new_g + manhattan(new_state) #计算新状态的g值和f值
                #如果新状态未被访问过，或者当前路径的g值更小，则更新
                if new_state not in visited or visited[new_state] > new_g:
                    visited[new_state] = new_g
                    heapq.heappush(heap, (new_f, new_g, new_state, path + move))
    print("unsolvable")
if __name__ == "__main__":
    solve_puzzle()
